#! /bin/usr/env python
# D.J. Bennett
# 26/05/2014
"""
Tests for phylogeny tools.
"""

import unittest
import pickle
import os
import shutil
from Bio import Phylo
from Bio import AlignIO
from cStringIO import StringIO
import pglt.tools.phylogeny_tools as ptools

# DIRS
working_dir = os.path.dirname(__file__)


# MOCK DATA
with open(os.path.join(working_dir, "data", "test_alignment.p"), "rb") as file:
    test_alignment = pickle.load(file)

with open(os.path.join(working_dir, "data", "test_alignments.p"), "rb") \
        as file:
    test_alignments = pickle.load(file)

with open(os.path.join(working_dir, "data", "test_phylo.p"), "rb") as file:
    phylo = pickle.load(file)

with open(os.path.join(working_dir, "data", "test_constraint.tre"), "r") \
        as file:
    constraint = Phylo.read(file, 'newick')

partitions = [0, 1761, 3141]


# FUNCTIONS
class AlignmentSeq(object):

    def __init__(self, name):
        self.id = name


def genAlignment(names):
    # little function that generates a list of sequences
    #  looks like an alignment to getOutgroup
    return [AlignmentSeq(e) for e in names]


class PhylogenyTestSuite(unittest.TestCase):

    def setUp(self):
        self.partitions = partitions
        self.phylo = phylo
        self.constraint_opt = ' -g .constraint.tre'
        self.constraint = constraint

    def tearDown(self):
        # remove all files potentially generated by ptools
        ptool_files = ['.constraint.tre', 'distribution.tre', 'consensus.tre',
                       '.phylogeny_in.phylip.reduced',
                       'RAxML_info..phylogeny_out', '.phylogeny_in.phylip',
                       '.partitions.txt.reduced', '.partitions.txt']
        while ptool_files:
            try:
                ptool_file = ptool_files.pop()
                os.remove(ptool_file)
            except OSError:
                pass
        phylogeny_folders = ['3_alignment', '4_phylogeny']
        while phylogeny_folders:
            try:
                phylogeny_folder = phylogeny_folders.pop()
                shutil.rmtree(phylogeny_folder)
            except OSError:
                pass

    def test_stop_codon_retriever(self):
        # eukaryota, vertebrate, tetrapod, mammal, boreoeutherian, primate,hsap
        human_ids = [2759, 7742, 32523, 40674, 1437010, 9443, 9606]
        # eukaryota, diplomonad, Hexamitidae, h. inflata
        hinflata_ids = [2759, 5738, 5739, 28002]
        retriever = ptools.StopCodonRetriever()
        human_pattern = retriever.pattern(ids=human_ids)
        hinflata_pattern = retriever.pattern(ids=hinflata_ids)
        # humans are vertebrates
        self.assertEqual(human_pattern[0].pattern, '(taa|tag|aga|agg)')
        # h.inflata are ciliates
        self.assertEqual(hinflata_pattern[0].pattern, 'tag')

    def test_alignment_store(self):
        # generate fake alignment folders
        clusters = ['gene1_cluster0', 'gene2_cluster0']
        indir = '3_alignment'
        os.mkdir(indir)
        j = 0
        for cluster in clusters:
            os.mkdir(os.path.join(indir, cluster))
            for i in range(10):
                fname = '{0}_testalignment{1}.faa'.format(i, j)
                directory = os.path.join(indir, cluster, fname)
                with open(directory, "w") as file:
                    AlignIO.write(test_alignments[j], file, "fasta")
            j += 1
        # generate fake dict
        genedict = {'gene1': {'partition': 'False'},
                    'gene2': {'partition': 'False'}}
        # create store
        store = ptools.AlignmentStore(clusters=clusters, genedict=genedict,
                                      allrankids=[], indir=indir)
        # check it works
        alignments, stops = store.pull()
        # should return one of each test alignments
        alens = [len(e) for e in alignments]
        self.assertTrue(len(test_alignments[0]) in alens)
        self.assertTrue(len(test_alignments[1]) in alens)
        self.assertEqual(stops, stops)

    def test_generator_private_test(self):
        pass

    def test_generator_private_concatenate(self):
        pass

    def test_generator_private_constraint(self):
        pass

    def test_generator_private_outgroup(self):
        pass

    def test_generator_private_findorf(self):
        pass

    def test_generator_private_partition(self):
        pass

    def test_generator_private_setup(self):
        pass

    def test_generator_run(self):
        pass

    def test_raxml(self):
        pass
        # # first write out a .constraint.tre
        # with open('.constraint.tre', 'w') as file:
        #     Phylo.write(self.constraint, file, 'newick')
        # phylo = ptools.RAxML(self.alignment, partitions=self.partitions,
        #                      outgroup="Ignatius_tetrasporus",
        #                      constraint=self.constraint_opt)
        # self.assertTrue(phylo)

    def test_consensus(self):
        pass
        # # create a list of trees, save it to file, check if consensus.tre
        # phylogenies = [self.phylo for i in range(100)]
        # with open('distribution.tre', "w") as file:
        #     Phylo.write(phylogenies, file, 'newick')
        # ptools.consensus('distribution.tre', 'consensus.tre', min_freq=0.5,
        #                  is_rooted=True, trees_splits_encoded=False)
        # self.assertTrue(os.path.isfile('consensus.tre'))

    # def test_getbranchlengths(self):
    #     # 15 tips, one in-group, one root
    #     # lengths are all scaled to 1
    #     # total branch length should equal 17
    #     res = ptools.getBranchLengths(self.phylo)
    #     self.assertEqual(sum(res), 17)

    # def test_test(self):
    #     res = ptools.test(self.phylo, 0.5)
    #     self.assertTrue(res)

    # def test_concatenatealignments(self):
    #     res_alignment, res_partitions = \
    #         ptools.concatenateAlignments(self.alignments)
    #     self.assertEqual(res_partitions, self.partitions)
    #     seq = self.alignment[0]
    #     for each in res_alignment:
    #         if each.id == seq.id:
    #             res_seq = each
    #     self.assertEqual(str(res_seq.seq), str(seq.seq))
    #
    # def test_genconstrainttree(self):
    #     # 4 tips not present in alignment
    #     res = ptools.genConstraintTree(self.alignment,
    #                                    os.path.join(working_dir, 'data',
    #                                                 'test_phylo.tre'))
    #     self.assertEqual(len(res.get_terminals()), 11)

    # def test_genconstraintarg(self):
    #     constraint = ptools.genConstraintTree(self.alignment,
    #                                           os.path.join(working_dir, 'data',
    #                                                        'test_phylo.tre'))
    #     res_opt = ptools.getConstraintArg(constraint)
    #     self.assertTrue(os.path.isfile('.constraint.tre'))
    #     self.assertEqual(res_opt, self.constraint_opt)

    # def test_getoutgroup(self):
    #     # check with outgroup
    #     alignment = genAlignment(['outgroup', 'F', 'B', 'H'])
    #     treestr = '((outgroup:0.1,F:0.1):0.1,(B:0.1,H:0.1):0.1);'
    #     tree = Phylo.read(StringIO(treestr), "newick")
    #     res = ptools.getOutgroup(alignment, tree)
    #     self.assertEqual(res, 'outgroup')
    #     # try without outgroup
    #     alignment = genAlignment(['D', 'F', 'B', 'H'])
    #     treestr = '((D:0.1,F:0.1):0.1,(B:0.1,H:0.1):0.1);'
    #     tree = Phylo.read(StringIO(treestr), "newick")
    #     res = ptools.getOutgroup(alignment, tree)
    #     self.assertNotEqual(res, 'outgroup')

if __name__ == '__main__':
    unittest.main()
