#!/usr/bin/python
## No warranty, no copyright
## Dominic John Bennett
## 13/06/2013
## Generate trees based on taxonomic lineages as generated by taxonNamesResolver
## TODO(Dom/13/06/2013): What if higher taxonomic names share the same names?

import collections

def genTaxTree(idents, lineages, ranks):
	"""Generate Newick tree from GNR lineage:
	Args:
	-- idents: the identities of the species (e.g. names or taxids)
	-- lineages: the lineage produced by GNR ('classification_path' in GNR)
	
	Doctest:
	>>> lineages = ['|O1|F1|G1','|O1|F1|G2','|O1|F2|G3','|O2|F3|G4','|O2|F3|G5']
	>>> ranks = ['|O|F|G','|O|F|G','|O|F|G','|O|F|G','|O|F|G']
	>>> idents = [1, 2, 3, 4, 5]
	>>> genTaxTree(idents, lineages, ranks)
	'((4,5),(3,(1,2)));'
	"""
	# convert |A|B|C to ['C', 'B', 'A']
	for i, lineage in enumerate(lineages):
		lineage = lineage.split('|')
		lineage.reverse()
		lineages[i] = lineage
	for i, rank in enumerate(ranks):
		rank = rank.split('|')
		rank.reverse()
		ranks[i] = rank
	# make lineages of same ranks
	all_ranks = [e2 for e1 in ranks for e2 in e1]
	rank_freq =  collections.Counter(all_ranks).items()
	shared_ranks = [e for e, f in rank_freq if f == len(idents)]
	line_bool = [[1 if e2 in shared_ranks else 0 for e2 in e1] for e1 in ranks]
	lineages = [[lineages[i1][i2] for i2, e2 in enumerate(e1) if e2 == 1] for i1, e1 in enumerate(line_bool)]
	all_lines = [e2 for e1 in lineages for e2 in e1]
	line_freq =  collections.Counter(all_lines).items()
	shared_lineage = [e for e, f in line_freq if f == len(idents)]
	# if shared lineage is empty... drop radically different taxa
	
	# create line_obj, a tuple of ident and lineage
	line_obj = zip(idents, lineages)
	for i in range(len(lineages[0])):
		for uniq in set([each[1][i] for each in line_obj]):
			# find shared taxonomic groups
			new_node = [each[0] for each in line_obj if each[1][i] == uniq]
			if len(new_node) > 1:
				# extract shared lineage
				lineage = [each[1] for each in line_obj if each[0] == new_node[0]]
				# remove shareds from line_obj
				line_obj = [each for each in line_obj if not each[0] in new_node]
				# convert to strings
				new_node = [str(each) for each in new_node]
				# add new node to line_obj
				new_node = ('(' + ','.join(new_node) + ')', lineage[0])
				line_obj.append(new_node)
		if len(line_obj) < 1:
			break
	return (line_obj[0][0] + ';', shared_lineage)
	
if __name__ == '__main__':
	import doctest
	doctest.testmod()
